//! *************************************************************************
//! **  This file is auto-generated by gen_math, do not edit it manually.  **
//! *************************************************************************

#pragma once
#include <cstdint>
#include <cmath>
#include "../gen_math_fwd.hpp"
#include "../vec/double_vec.hpp"
#include <SkrBase/misc/debug.h>
#include <SkrBase/misc/hash.hpp>

namespace skr {
inline namespace math {
//! row major matrix
struct double3x3 {
    union {
        // axis based
        struct {
            double3 axis_x;
            double3 axis_y;
            double3 axis_z;
        };
        
        // direction based
        struct {
            double3 right;
            double3 up;
            double3 forward;
        };
        
        // row based
        double3 rows[3];
        
        // vector based
        struct {
            double m00, m01, m02;
            double m10, m11, m12;
            double m20, m21, m22;
        };
    };
    
    // ctor & dtor
    inline double3x3() : axis_x(0), axis_y(0), axis_z(0) {}
    inline double3x3(MathNoInitType) {}
    inline double3x3(
        double m00, double m01, double m02,
        double m10, double m11, double m12,
        double m20, double m21, double m22
    ):
        m00(m00), m01(m01), m02(m02),
        m10(m10), m11(m11), m12(m12),
        m20(m20), m21(m21), m22(m22)
    {}
    inline double3x3(double3 axis_x, double3 axis_y, double3 axis_z) noexcept : axis_x(axis_x), axis_y(axis_y), axis_z(axis_z) {}
    inline ~double3x3() = default;
    
    // convert with other dimensions
    explicit double3x3(const double4x4& rhs);
    
    // convert with other component kinds
    double3x3(const float3x3& rhs);
    
    // factory
    inline static double3x3 eye(double v) {
        return double3x3{
            v, 0, 0,
            0, v, 0,
            0, 0, v
        };
    }
    inline static double3x3 fill(double v) {
        return double3x3{
            v, v, v,
            v, v, v,
            v, v, v
        };
    }
    inline static double3x3 identity() { return eye(1); }
    inline static double3x3 zero() { return fill(0); }
    inline static double3x3 one() { return fill(1); }
    inline static double3x3 transposed(
        double m00, double m10, double m20,
        double m01, double m11, double m21,
        double m02, double m12, double m22
    ) {
        return {
            m00, m01, m02,
            m10, m11, m12,
            m20, m21, m22
        };
    }
    
    // factory for utility usage
    static double3x3 from_scale(const double3& scale);
    
    // copy & move & assign & move assign
    inline double3x3(const double3x3& rhs) noexcept : axis_x(rhs.axis_x), axis_y(rhs.axis_y), axis_z(rhs.axis_z) {}
    inline double3x3(double3x3&& rhs) noexcept : axis_x(std::move(rhs.axis_x)), axis_y(std::move(rhs.axis_y)), axis_z(std::move(rhs.axis_z)) {}
    inline double3x3& operator=(const double3x3& rhs) noexcept { this->axis_x = rhs.axis_x; this->axis_y = rhs.axis_y; this->axis_z = rhs.axis_z; return *this; }
    inline double3x3& operator=(double3x3&& rhs) noexcept { this->axis_x = std::move(rhs.axis_x); this->axis_y = std::move(rhs.axis_y); this->axis_z = std::move(rhs.axis_z); return *this; }
    
    // mul operator
    friend double3x3 operator*(const double3x3& lhs, const double3x3& rhs);
    double3x3& operator*=(const double3x3& rhs);
    friend double3 operator*(const double3& lhs, const double3x3& rhs);
};
//! row major matrix
struct alignas(16) double4x4 {
    union {
        // axis based
        struct {
            double4 axis_x;
            double4 axis_y;
            double4 axis_z;
            double4 axis_w;
        };
        
        // direction based
        struct {
            double4 right;
            double4 up;
            double4 forward;
            double4 translation;
        };
        
        // row based
        double4 rows[4];
        
        // vector based
        struct {
            double m00, m01, m02, m03;
            double m10, m11, m12, m13;
            double m20, m21, m22, m23;
            double m30, m31, m32, m33;
        };
    };
    
    // ctor & dtor
    inline double4x4() : axis_x(0), axis_y(0), axis_z(0), axis_w(0) {}
    inline double4x4(MathNoInitType) {}
    inline double4x4(
        double m00, double m01, double m02, double m03,
        double m10, double m11, double m12, double m13,
        double m20, double m21, double m22, double m23,
        double m30, double m31, double m32, double m33
    ):
        m00(m00), m01(m01), m02(m02), m03(m03),
        m10(m10), m11(m11), m12(m12), m13(m13),
        m20(m20), m21(m21), m22(m22), m23(m23),
        m30(m30), m31(m31), m32(m32), m33(m33)
    {}
    inline double4x4(double4 axis_x, double4 axis_y, double4 axis_z, double4 axis_w) noexcept : axis_x(axis_x), axis_y(axis_y), axis_z(axis_z), axis_w(axis_w) {}
    inline ~double4x4() = default;
    
    // convert with other dimensions
    explicit double4x4(const double3x3& rhs);
    
    // convert with other component kinds
    double4x4(const float4x4& rhs);
    
    // factory
    inline static double4x4 eye(double v) {
        return double4x4{
            v, 0, 0, 0,
            0, v, 0, 0,
            0, 0, v, 0,
            0, 0, 0, v
        };
    }
    inline static double4x4 fill(double v) {
        return double4x4{
            v, v, v, v,
            v, v, v, v,
            v, v, v, v,
            v, v, v, v
        };
    }
    inline static double4x4 identity() { return eye(1); }
    inline static double4x4 zero() { return fill(0); }
    inline static double4x4 one() { return fill(1); }
    inline static double4x4 transposed(
        double m00, double m10, double m20, double m30,
        double m01, double m11, double m21, double m31,
        double m02, double m12, double m22, double m32,
        double m03, double m13, double m23, double m33
    ) {
        return {
            m00, m01, m02, m03,
            m10, m11, m12, m13,
            m20, m21, m22, m23,
            m30, m31, m32, m33
        };
    }
    
    // factory for utility usage
    static double4x4 from_scale(const double3& scale);
    static double4x4 from_translation(const double3& translation);
    static double4x4 look_to(const double3& from, const double3& dir, const double3& up);
    static double4x4 look_at(const double3& from, const double3& to, const double3& up);
    static double4x4 view_to(const double3& from, const double3& dir, const double3& up);
    static double4x4 view_at(const double3& from, const double3& to, const double3& up);
    static double4x4 perspective(double view_width, double view_height, double near_distance, double far_distance);
    static double4x4 perspective_fov(double fov_y, double aspect_ratio, double near_distance, double far_distance);
    static double4x4 orthographic(double width, double height, double near_distance, double far_distance);
    
    // copy & move & assign & move assign
    inline double4x4(const double4x4& rhs) noexcept : axis_x(rhs.axis_x), axis_y(rhs.axis_y), axis_z(rhs.axis_z), axis_w(rhs.axis_w) {}
    inline double4x4(double4x4&& rhs) noexcept : axis_x(std::move(rhs.axis_x)), axis_y(std::move(rhs.axis_y)), axis_z(std::move(rhs.axis_z)), axis_w(std::move(rhs.axis_w)) {}
    inline double4x4& operator=(const double4x4& rhs) noexcept { this->axis_x = rhs.axis_x; this->axis_y = rhs.axis_y; this->axis_z = rhs.axis_z; this->axis_w = rhs.axis_w; return *this; }
    inline double4x4& operator=(double4x4&& rhs) noexcept { this->axis_x = std::move(rhs.axis_x); this->axis_y = std::move(rhs.axis_y); this->axis_z = std::move(rhs.axis_z); this->axis_w = std::move(rhs.axis_w); return *this; }
    
    // mul operator
    friend double4x4 operator*(const double4x4& lhs, const double4x4& rhs);
    double4x4& operator*=(const double4x4& rhs);
    friend double4 operator*(const double4& lhs, const double4x4& rhs);
};

}
}
