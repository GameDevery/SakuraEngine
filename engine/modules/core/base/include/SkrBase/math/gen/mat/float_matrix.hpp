//! *************************************************************************
//! **  This file is auto-generated by gen_math, do not edit it manually.  **
//! *************************************************************************

#pragma once
#include <cstdint>
#include <cmath>
#include "../gen_math_fwd.hpp"
#include "../vec/float_vec.hpp"
#include <SkrBase/misc/debug.h>
#include <SkrBase/misc/hash.hpp>

namespace skr {
inline namespace math {
//! row major matrix
struct float3x3 {
    union {
        // axis based
        struct {
            float3 axis_x;
            float3 axis_y;
            float3 axis_z;
        };
        
        // direction based
        struct {
            float3 right;
            float3 up;
            float3 forward;
        };
        
        // row based
        float3 rows[3];
        
        // vector based
        struct {
            float m00, m01, m02;
            float m10, m11, m12;
            float m20, m21, m22;
        };
    };
    
    // ctor & dtor
    inline float3x3() : axis_x(0), axis_y(0), axis_z(0) {}
    inline float3x3(MathNoInitType) {}
    inline float3x3(
        float m00, float m01, float m02,
        float m10, float m11, float m12,
        float m20, float m21, float m22
    ):
        m00(m00), m01(m01), m02(m02),
        m10(m10), m11(m11), m12(m12),
        m20(m20), m21(m21), m22(m22)
    {}
    inline float3x3(float3 axis_x, float3 axis_y, float3 axis_z) noexcept : axis_x(axis_x), axis_y(axis_y), axis_z(axis_z) {}
    inline ~float3x3() = default;
    
    // convert with other dimensions
    explicit float3x3(const float4x4& rhs);
    
    // convert with other component kinds
    explicit float3x3(const double3x3& rhs);
    
    // factory
    inline static float3x3 eye(float v) {
        return float3x3{
            v, 0, 0,
            0, v, 0,
            0, 0, v
        };
    }
    inline static float3x3 fill(float v) {
        return float3x3{
            v, v, v,
            v, v, v,
            v, v, v
        };
    }
    inline static float3x3 identity() { return eye(1); }
    inline static float3x3 zero() { return fill(0); }
    inline static float3x3 one() { return fill(1); }
    inline static float3x3 transposed(
        float m00, float m10, float m20,
        float m01, float m11, float m21,
        float m02, float m12, float m22
    ) {
        return {
            m00, m01, m02,
            m10, m11, m12,
            m20, m21, m22
        };
    }
    
    // factory for utility usage
    static float3x3 from_scale(const float3& scale);
    
    // copy & move & assign & move assign
    inline float3x3(const float3x3& rhs) noexcept : axis_x(rhs.axis_x), axis_y(rhs.axis_y), axis_z(rhs.axis_z) {}
    inline float3x3(float3x3&& rhs) noexcept : axis_x(std::move(rhs.axis_x)), axis_y(std::move(rhs.axis_y)), axis_z(std::move(rhs.axis_z)) {}
    inline float3x3& operator=(const float3x3& rhs) noexcept { this->axis_x = rhs.axis_x; this->axis_y = rhs.axis_y; this->axis_z = rhs.axis_z; return *this; }
    inline float3x3& operator=(float3x3&& rhs) noexcept { this->axis_x = std::move(rhs.axis_x); this->axis_y = std::move(rhs.axis_y); this->axis_z = std::move(rhs.axis_z); return *this; }
    
    // visitor operator
    inline float3 operator[](size_t idx) const { SKR_ASSERT(idx < 3); return rows[idx]; }
    inline float3& operator[](size_t idx) { SKR_ASSERT(idx < 3); return rows[idx]; }

    // mul operator
    friend float3x3 operator*(const float3x3& lhs, const float3x3& rhs);
    float3x3& operator*=(const float3x3& rhs);
    friend float3 operator*(const float3& lhs, const float3x3& rhs);
};
//! row major matrix
struct alignas(16) float4x4 {
    union {
        // axis based
        struct {
            float4 axis_x;
            float4 axis_y;
            float4 axis_z;
            float4 axis_w;
        };
        
        // direction based
        struct {
            float4 right;
            float4 up;
            float4 forward;
            float4 translation;
        };
        
        // row based
        float4 rows[4];
        
        // vector based
        struct {
            float m00, m01, m02, m03;
            float m10, m11, m12, m13;
            float m20, m21, m22, m23;
            float m30, m31, m32, m33;
        };
    };
    
    // ctor & dtor
    inline float4x4() : axis_x(0), axis_y(0), axis_z(0), axis_w(0) {}
    inline float4x4(MathNoInitType) {}
    inline float4x4(
        float m00, float m01, float m02, float m03,
        float m10, float m11, float m12, float m13,
        float m20, float m21, float m22, float m23,
        float m30, float m31, float m32, float m33
    ):
        m00(m00), m01(m01), m02(m02), m03(m03),
        m10(m10), m11(m11), m12(m12), m13(m13),
        m20(m20), m21(m21), m22(m22), m23(m23),
        m30(m30), m31(m31), m32(m32), m33(m33)
    {}
    inline float4x4(float4 axis_x, float4 axis_y, float4 axis_z, float4 axis_w) noexcept : axis_x(axis_x), axis_y(axis_y), axis_z(axis_z), axis_w(axis_w) {}
    inline ~float4x4() = default;
    
    // convert with other dimensions
    explicit float4x4(const float3x3& rhs);
    
    // convert with other component kinds
    explicit float4x4(const double4x4& rhs);
    
    // factory
    inline static float4x4 eye(float v) {
        return float4x4{
            v, 0, 0, 0,
            0, v, 0, 0,
            0, 0, v, 0,
            0, 0, 0, v
        };
    }
    inline static float4x4 fill(float v) {
        return float4x4{
            v, v, v, v,
            v, v, v, v,
            v, v, v, v,
            v, v, v, v
        };
    }
    inline static float4x4 identity() { return eye(1); }
    inline static float4x4 zero() { return fill(0); }
    inline static float4x4 one() { return fill(1); }
    inline static float4x4 transposed(
        float m00, float m10, float m20, float m30,
        float m01, float m11, float m21, float m31,
        float m02, float m12, float m22, float m32,
        float m03, float m13, float m23, float m33
    ) {
        return {
            m00, m01, m02, m03,
            m10, m11, m12, m13,
            m20, m21, m22, m23,
            m30, m31, m32, m33
        };
    }
    
    // factory for utility usage
    static float4x4 from_scale(const float3& scale);
    static float4x4 from_translation(const float3& translation);
    static float4x4 look_to(const float3& from, const float3& dir, const float3& up);
    static float4x4 look_at(const float3& from, const float3& to, const float3& up);
    static float4x4 view_to(const float3& from, const float3& dir, const float3& up);
    static float4x4 view_at(const float3& from, const float3& to, const float3& up);
    static float4x4 perspective(float view_width, float view_height, float near_distance, float far_distance);
    static float4x4 perspective_fov(float fov_y, float aspect_ratio, float near_distance, float far_distance);
    static float4x4 orthographic(float width, float height, float near_distance, float far_distance);
    
    // copy & move & assign & move assign
    inline float4x4(const float4x4& rhs) noexcept : axis_x(rhs.axis_x), axis_y(rhs.axis_y), axis_z(rhs.axis_z), axis_w(rhs.axis_w) {}
    inline float4x4(float4x4&& rhs) noexcept : axis_x(std::move(rhs.axis_x)), axis_y(std::move(rhs.axis_y)), axis_z(std::move(rhs.axis_z)), axis_w(std::move(rhs.axis_w)) {}
    inline float4x4& operator=(const float4x4& rhs) noexcept { this->axis_x = rhs.axis_x; this->axis_y = rhs.axis_y; this->axis_z = rhs.axis_z; this->axis_w = rhs.axis_w; return *this; }
    inline float4x4& operator=(float4x4&& rhs) noexcept { this->axis_x = std::move(rhs.axis_x); this->axis_y = std::move(rhs.axis_y); this->axis_z = std::move(rhs.axis_z); this->axis_w = std::move(rhs.axis_w); return *this; }
    
    // visitor operator
    inline float4 operator[](size_t idx) const { SKR_ASSERT(idx < 4); return rows[idx]; }
    inline float4& operator[](size_t idx) { SKR_ASSERT(idx < 4); return rows[idx]; }

    // mul operator
    friend float4x4 operator*(const float4x4& lhs, const float4x4& rhs);
    float4x4& operator*=(const float4x4& rhs);
    friend float4 operator*(const float4& lhs, const float4x4& rhs);
};

}
}
