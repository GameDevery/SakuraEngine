#include <std/std.hpp>
#include <std2/attributes.hpp>
#include <std2/constant_buffer.hpp>
#include "SkrRenderer/shared/gpu_scene.hpp"
#include "SkrRenderer/shared/soa_layout.hpp"

using namespace skr::shader;
using namespace skr;

// External resource bindings
RWTexture2D<float> output_texture;
ByteAddressBuffer gpu_scene_buffer; // Core data buffer from GPUScene

// Push constants for debug parameters
struct SceneDebugConstants 
{
    float2 screenSize;
    uint32 debug_mode;     // 0 = red fill, 1 = checkerboard, 2 = UV gradient, 3 = GPUScene color debug, 6 = 3D sphere rendering
    uint32 instance_count; // Number of instances in GPUScene
};

[[push_constant]]
ConstantBuffer<SceneDebugConstants> debug_constants;

// Simple red fill compute shader
[[compute_shader("scene_debug"), kernel_2d(16, 16)]]
void scene_debug([[sv_thread_id]] uint3 thread_id) 
{
    uint2 screen_size = uint2(debug_constants.screenSize);
    uint2 pixel_coord = thread_id.xy;

    // Boundary check
    if (any(pixel_coord >= screen_size)) {
        return;
    }
    
    // Debug rendering based on mode
    float4 pixel_color;
    
    switch (debug_constants.debug_mode) {
        case 0: // Red fill
        {
            pixel_color = float4(1.0f, 0.0f, 0.0f, 1.0f);
            break;
        }
            
        case 1: // Checkerboard pattern
        {
            float2 uv = float2(pixel_coord) / float2(screen_size);
            float checker_size = 32.0f;
            float2 checker_uv = uv * checker_size;
            uint2 checker_coord = uint2(checker_uv);
            bool is_even = ((checker_coord.x + checker_coord.y) % 2) == 0;
            pixel_color = is_even ? float4(1.0f, 0.0f, 0.0f, 1.0f) : float4(0.0f, 1.0f, 0.0f, 1.0f);
            break;
        }
        
        case 2: // UV gradient
        {
            float2 uv = float2(pixel_coord) / float2(screen_size);
            pixel_color = float4(uv.x, uv.y, 0.0f, 1.0f);
            break;
        }
        
        case 3: // GPUScene color debug - visualize color data from GPU buffer
        {
            // Map pixel position to instance index (show multiple instances in a grid)
            uint instances_per_row = uint(sqrt(float(debug_constants.instance_count))) + 1;
            uint block_size = uint(screen_size.x / instances_per_row);
            
            uint instance_x = pixel_coord.x / block_size;
            uint instance_y = pixel_coord.y / block_size;
            uint instance_index = instance_y * instances_per_row + instance_x;
            
            if (instance_index < debug_constants.instance_count) {
                // Use DefaultGPUSceneLayout to calculate offset directly
                uint color_offset = DefaultGPUSceneLayout::component_location<GPUSceneInstanceColor>(instance_index);
                
                // Read color data from GPU buffer
                GPUSceneInstanceColor color_data = gpu_scene_buffer.Load<GPUSceneInstanceColor>(color_offset);
                float4 instance_color = float4(color_data.color[0], color_data.color[1],
                                              color_data.color[2], color_data.color[3]);
                
                // Draw border for each instance block
                uint2 block_coord = pixel_coord % block_size;
                if (block_coord.x < 2 || block_coord.y < 2 || 
                    block_coord.x >= block_size - 2 || block_coord.y >= block_size - 2) {
                    pixel_color = float4(0.0f, 0.0f, 0.0f, 1.0f); // Black border
                } else {
                    pixel_color = instance_color;
                }
            } else {
                // Background for areas without instances
                pixel_color = float4(0.2f, 0.2f, 0.2f, 1.0f);
            }
            break;
        }
        
        case 4: // Simple GPUScene validation - show first instance color across entire screen
        {
            if (debug_constants.instance_count > 0) {
                // Read the first instance's color using DefaultGPUSceneLayout
                constexpr uint color_offset = DefaultGPUSceneLayout::component_location<GPUSceneInstanceColor>(0);
                GPUSceneInstanceColor color_data = gpu_scene_buffer.Load<GPUSceneInstanceColor>(color_offset);
                float4 first_color = float4(color_data.color[0], color_data.color[1],
                                           color_data.color[2], color_data.color[3]);
                
                pixel_color = first_color;
                
                // Add instance count indicator in top-left corner
                if (pixel_coord.x < 100 && pixel_coord.y < 20) {
                    float indicator = float(pixel_coord.x) / 100.0f;
                    float normalized_count = float(debug_constants.instance_count) / 100.0f;
                    if (indicator < normalized_count) {
                        pixel_color = float4(0.0f, 1.0f, 0.0f, 1.0f); // Green bar showing instance count
                    }
                }
            } else {
                pixel_color = float4(0.5f, 0.0f, 0.0f, 1.0f); // Dark red for no instances
            }
            break;
        }
        
        case 5: // Test mode - show fixed color based on instance count
        {
            if (debug_constants.instance_count > 0) {
                // Show yellow if we have instances
                pixel_color = float4(1.0f, 1.0f, 0.0f, 1.0f);
                
                // Show debug info in corners
                if (pixel_coord.x < 200 && pixel_coord.y < 40) {
                    // Top-left: instance count bar
                    if (pixel_coord.y < 20) {
                        float indicator = float(pixel_coord.x) / 200.0f;
                        float normalized_count = float(debug_constants.instance_count) / 10000.0f;
                        if (indicator < normalized_count) {
                            pixel_color = float4(0.0f, 1.0f, 0.0f, 1.0f); // Green
                        }
                    } else {
                        // Show instance count as blue gradient
                        float count_norm = float(debug_constants.instance_count) / 65536.0f;
                        pixel_color = float4(0.0f, 0.0f, count_norm, 1.0f);
                    }
                }
            } else {
                pixel_color = float4(0.5f, 0.0f, 0.0f, 1.0f); // Dark red for no instances
            }
            break;
        }
        
        case 6: // 3D sphere rendering mode
        {
            // Convert pixel coordinates to NDC space (-1 to 1)
            float2 ndc = (float2(pixel_coord) / float2(screen_size)) * 2.0f - 1.0f;
            ndc.y = -ndc.y; // Flip Y coordinate for correct orientation
            
            // Simple orthographic projection - ray starts at (ndc.x, ndc.y, 1) going towards -Z
            float3 ray_origin = float3(ndc.x, ndc.y, 1.0f);
            float3 ray_direction = float3(0.0f, 0.0f, -1.0f);
            
            pixel_color = float4(0.1f, 0.1f, 0.2f, 1.0f); // Dark blue background
            float closest_distance = 10.0f; // Far distance
            
            // Check intersection with all sphere instances
            for (uint instance_index = 0; instance_index < debug_constants.instance_count; instance_index++) {
                // Use DefaultGPUSceneLayout to calculate transform offset
                uint transform_offset = DefaultGPUSceneLayout::component_location<GPUSceneObjectToWorld>(instance_index);
                
                // Load 4x4 transform matrix manually (16 floats = 64 bytes)
                // This ensures we're reading in the expected memory layout
                float4x4 object_to_world = gpu_scene_buffer.Load<GPUSceneObjectToWorld>(transform_offset).matrix;
                object_to_world = transpose(object_to_world);
                /*
                float4x4 object_to_world;
                for (uint row = 0; row < 4; row++) {
                    for (uint col = 0; col < 4; col++) {
                        uint matrix_offset = transform_offset + (row * 4 + col) * 4;
                        object_to_world[row][col] = gpu_scene_buffer.Load<float>(matrix_offset);
                    }
                }
                */

                // Extract position and scale from transform matrix
                // The matrix is stored row-major, so position is in the last row (row 3)
                float3 sphere_center = float3(object_to_world[3][0], object_to_world[3][1], object_to_world[3][2]);
                // Scale is the length of the first column vector (X axis)
                float sphere_radius = length(float3(object_to_world[0][0], object_to_world[1][0], object_to_world[2][0]));
                
                // Ray-sphere intersection test
                float3 to_center = ray_origin - sphere_center;
                float a = dot(ray_direction, ray_direction);
                float b = 2.0f * dot(to_center, ray_direction);
                float c = dot(to_center, to_center) - sphere_radius * sphere_radius;
                
                float discriminant = b * b - 4.0f * a * c;
                if (discriminant >= 0.0f) {
                    float distance = (-b - sqrt(discriminant)) / (2.0f * a);
                    if (distance > 0.0f && distance < closest_distance) {
                        closest_distance = distance;

                        // Read color for this instance using DefaultGPUSceneLayout
                        uint color_offset = DefaultGPUSceneLayout::component_location<GPUSceneInstanceColor>(instance_index);
                        GPUSceneInstanceColor color_data = gpu_scene_buffer.Load<GPUSceneInstanceColor>(color_offset);
                        float4 sphere_color = float4(color_data.color[0], color_data.color[1], 
                                                    color_data.color[2], color_data.color[3]);
                        
                        // Simple lighting calculation
                        float3 hit_point = ray_origin + ray_direction * distance;
                        float3 normal = normalize(hit_point - sphere_center);
                        float3 light_dir = normalize(float3(1.0f, 1.0f, 1.0f));
                        float light_intensity = max(0.3f, dot(normal, light_dir));
                        
                        pixel_color = float4(sphere_color.rgb * light_intensity, sphere_color.a);
                    }
                }
            }
            break;
        }
        
        default: // Magenta for unknown mode
            pixel_color = float4(1.0f, 0.0f, 1.0f, 1.0f);
            break;
    }
    
    // Write pixel color to output texture
    output_texture.store(pixel_coord, pixel_color);
}