//! *************************************************************************
//! **  This file is auto-generated by gen_math, do not edit it manually.  **
//! *************************************************************************

#pragma once
#include "../vec/bool_vec.hpp"
#include "../vec/float_vec.hpp"
#include "../../math_constants.hpp"

namespace skr {
inline namespace math {
// abs
float abs(float v);
float2 abs(const float2& v);
float3 abs(const float3& v);
float4 abs(const float4& v);

// acos
inline float acos(float v) { return ::std::acos(v); }
inline float2 acos(const float2& v) { return {::std::acos(v.x), ::std::acos(v.y)}; }
inline float3 acos(const float3& v) { return {::std::acos(v.x), ::std::acos(v.y), ::std::acos(v.z)}; }
inline float4 acos(const float4& v) { return {::std::acos(v.x), ::std::acos(v.y), ::std::acos(v.z), ::std::acos(v.w)}; }

// acosh
inline float acosh(float v) { return ::std::acosh(v); }
inline float2 acosh(const float2& v) { return {::std::acosh(v.x), ::std::acosh(v.y)}; }
inline float3 acosh(const float3& v) { return {::std::acosh(v.x), ::std::acosh(v.y), ::std::acosh(v.z)}; }
inline float4 acosh(const float4& v) { return {::std::acosh(v.x), ::std::acosh(v.y), ::std::acosh(v.z), ::std::acosh(v.w)}; }

// cos
inline float cos(float v) { return ::std::cos(v); }
inline float2 cos(const float2& v) { return {::std::cos(v.x), ::std::cos(v.y)}; }
inline float3 cos(const float3& v) { return {::std::cos(v.x), ::std::cos(v.y), ::std::cos(v.z)}; }
inline float4 cos(const float4& v) { return {::std::cos(v.x), ::std::cos(v.y), ::std::cos(v.z), ::std::cos(v.w)}; }

// cosh
inline float cosh(float v) { return ::std::cosh(v); }
inline float2 cosh(const float2& v) { return {::std::cosh(v.x), ::std::cosh(v.y)}; }
inline float3 cosh(const float3& v) { return {::std::cosh(v.x), ::std::cosh(v.y), ::std::cosh(v.z)}; }
inline float4 cosh(const float4& v) { return {::std::cosh(v.x), ::std::cosh(v.y), ::std::cosh(v.z), ::std::cosh(v.w)}; }

// asin
inline float asin(float v) { return ::std::asin(v); }
inline float2 asin(const float2& v) { return {::std::asin(v.x), ::std::asin(v.y)}; }
inline float3 asin(const float3& v) { return {::std::asin(v.x), ::std::asin(v.y), ::std::asin(v.z)}; }
inline float4 asin(const float4& v) { return {::std::asin(v.x), ::std::asin(v.y), ::std::asin(v.z), ::std::asin(v.w)}; }

// asinh
inline float asinh(float v) { return ::std::asinh(v); }
inline float2 asinh(const float2& v) { return {::std::asinh(v.x), ::std::asinh(v.y)}; }
inline float3 asinh(const float3& v) { return {::std::asinh(v.x), ::std::asinh(v.y), ::std::asinh(v.z)}; }
inline float4 asinh(const float4& v) { return {::std::asinh(v.x), ::std::asinh(v.y), ::std::asinh(v.z), ::std::asinh(v.w)}; }

// sin
inline float sin(float v) { return ::std::sin(v); }
inline float2 sin(const float2& v) { return {::std::sin(v.x), ::std::sin(v.y)}; }
inline float3 sin(const float3& v) { return {::std::sin(v.x), ::std::sin(v.y), ::std::sin(v.z)}; }
inline float4 sin(const float4& v) { return {::std::sin(v.x), ::std::sin(v.y), ::std::sin(v.z), ::std::sin(v.w)}; }

// sinh
inline float sinh(float v) { return ::std::sinh(v); }
inline float2 sinh(const float2& v) { return {::std::sinh(v.x), ::std::sinh(v.y)}; }
inline float3 sinh(const float3& v) { return {::std::sinh(v.x), ::std::sinh(v.y), ::std::sinh(v.z)}; }
inline float4 sinh(const float4& v) { return {::std::sinh(v.x), ::std::sinh(v.y), ::std::sinh(v.z), ::std::sinh(v.w)}; }

// atan
inline float atan(float v) { return ::std::atan(v); }
inline float2 atan(const float2& v) { return {::std::atan(v.x), ::std::atan(v.y)}; }
inline float3 atan(const float3& v) { return {::std::atan(v.x), ::std::atan(v.y), ::std::atan(v.z)}; }
inline float4 atan(const float4& v) { return {::std::atan(v.x), ::std::atan(v.y), ::std::atan(v.z), ::std::atan(v.w)}; }

// atanh
inline float atanh(float v) { return ::std::atanh(v); }
inline float2 atanh(const float2& v) { return {::std::atanh(v.x), ::std::atanh(v.y)}; }
inline float3 atanh(const float3& v) { return {::std::atanh(v.x), ::std::atanh(v.y), ::std::atanh(v.z)}; }
inline float4 atanh(const float4& v) { return {::std::atanh(v.x), ::std::atanh(v.y), ::std::atanh(v.z), ::std::atanh(v.w)}; }

// tan
inline float tan(float v) { return ::std::tan(v); }
inline float2 tan(const float2& v) { return {::std::tan(v.x), ::std::tan(v.y)}; }
inline float3 tan(const float3& v) { return {::std::tan(v.x), ::std::tan(v.y), ::std::tan(v.z)}; }
inline float4 tan(const float4& v) { return {::std::tan(v.x), ::std::tan(v.y), ::std::tan(v.z), ::std::tan(v.w)}; }

// tanh
inline float tanh(float v) { return ::std::tanh(v); }
inline float2 tanh(const float2& v) { return {::std::tanh(v.x), ::std::tanh(v.y)}; }
inline float3 tanh(const float3& v) { return {::std::tanh(v.x), ::std::tanh(v.y), ::std::tanh(v.z)}; }
inline float4 tanh(const float4& v) { return {::std::tanh(v.x), ::std::tanh(v.y), ::std::tanh(v.z), ::std::tanh(v.w)}; }

// sincos
inline void sincos(float v, float& out_sin, float& out_cos) { out_sin = ::std::sin(v); out_cos = ::std::cos(v); }
inline void sincos(const float2& v, float2& out_sin, float2& out_cos) { sincos(v.x, out_sin.x, out_cos.x); sincos(v.y, out_sin.y, out_cos.y); }
inline void sincos(const float3& v, float3& out_sin, float3& out_cos) { sincos(v.x, out_sin.x, out_cos.x); sincos(v.y, out_sin.y, out_cos.y); sincos(v.z, out_sin.z, out_cos.z); }
inline void sincos(const float4& v, float4& out_sin, float4& out_cos) { sincos(v.x, out_sin.x, out_cos.x); sincos(v.y, out_sin.y, out_cos.y); sincos(v.z, out_sin.z, out_cos.z); sincos(v.w, out_sin.w, out_cos.w); }

// atan2
inline float atan2(float y, float x) { return ::std::atan2(y, x); }
inline float2 atan2(const float2& y, const float2& x) { return {::std::atan2(y.x, x.x), ::std::atan2(y.y, x.y)}; }
inline float3 atan2(const float3& y, const float3& x) { return {::std::atan2(y.x, x.x), ::std::atan2(y.y, x.y), ::std::atan2(y.z, x.z)}; }
inline float4 atan2(const float4& y, const float4& x) { return {::std::atan2(y.x, x.x), ::std::atan2(y.y, x.y), ::std::atan2(y.z, x.z), ::std::atan2(y.w, x.w)}; }

// ceil
inline float ceil(float v) { return ::std::ceil(v); }
inline float2 ceil(const float2& v) { return {::std::ceil(v.x), ::std::ceil(v.y)}; }
inline float3 ceil(const float3& v) { return {::std::ceil(v.x), ::std::ceil(v.y), ::std::ceil(v.z)}; }
inline float4 ceil(const float4& v) { return {::std::ceil(v.x), ::std::ceil(v.y), ::std::ceil(v.z), ::std::ceil(v.w)}; }

// floor
inline float floor(float v) { return ::std::floor(v); }
inline float2 floor(const float2& v) { return {::std::floor(v.x), ::std::floor(v.y)}; }
inline float3 floor(const float3& v) { return {::std::floor(v.x), ::std::floor(v.y), ::std::floor(v.z)}; }
inline float4 floor(const float4& v) { return {::std::floor(v.x), ::std::floor(v.y), ::std::floor(v.z), ::std::floor(v.w)}; }

// round
inline float round(float v) { return ::std::round(v); }
inline float2 round(const float2& v) { return {::std::round(v.x), ::std::round(v.y)}; }
inline float3 round(const float3& v) { return {::std::round(v.x), ::std::round(v.y), ::std::round(v.z)}; }
inline float4 round(const float4& v) { return {::std::round(v.x), ::std::round(v.y), ::std::round(v.z), ::std::round(v.w)}; }

// trunc
inline float trunc(float v) { return ::std::trunc(v); }
inline float2 trunc(const float2& v) { return {::std::trunc(v.x), ::std::trunc(v.y)}; }
inline float3 trunc(const float3& v) { return {::std::trunc(v.x), ::std::trunc(v.y), ::std::trunc(v.z)}; }
inline float4 trunc(const float4& v) { return {::std::trunc(v.x), ::std::trunc(v.y), ::std::trunc(v.z), ::std::trunc(v.w)}; }

// frac
inline float frac(const float &v) { float int_ptr; return ::std::modf(v, &int_ptr); }
inline float2 frac(const float2 &v) { float2 int_ptr; return {::std::modf(v.x, &int_ptr.x), ::std::modf(v.y, &int_ptr.y)}; }
inline float3 frac(const float3 &v) { float3 int_ptr; return {::std::modf(v.x, &int_ptr.x), ::std::modf(v.y, &int_ptr.y), ::std::modf(v.z, &int_ptr.z)}; }
inline float4 frac(const float4 &v) { float4 int_ptr; return {::std::modf(v.x, &int_ptr.x), ::std::modf(v.y, &int_ptr.y), ::std::modf(v.z, &int_ptr.z), ::std::modf(v.w, &int_ptr.w)}; }

// modf
inline float modf(const float &v, float& int_part) { return ::std::modf(v, &int_part); }
inline float2 modf(const float2 &v, float2& int_part) { return { ::std::modf(v.x, &int_part.x), ::std::modf(v.y, &int_part.y) }; }
inline float3 modf(const float3 &v, float3& int_part) { return { ::std::modf(v.x, &int_part.x), ::std::modf(v.y, &int_part.y), ::std::modf(v.z, &int_part.z) }; }
inline float4 modf(const float4 &v, float4& int_part) { return { ::std::modf(v.x, &int_part.x), ::std::modf(v.y, &int_part.y), ::std::modf(v.z, &int_part.z), ::std::modf(v.w, &int_part.w) }; }

// fmod
inline float fmod(float x, float y) { return ::std::fmod(x, y); }
inline float2 fmod(const float2& x, const float2& y) { return {::std::fmod(x.x, y.x), ::std::fmod(x.y, y.y)}; }
inline float3 fmod(const float3& x, const float3& y) { return {::std::fmod(x.x, y.x), ::std::fmod(x.y, y.y), ::std::fmod(x.z, y.z)}; }
inline float4 fmod(const float4& x, const float4& y) { return {::std::fmod(x.x, y.x), ::std::fmod(x.y, y.y), ::std::fmod(x.z, y.z), ::std::fmod(x.w, y.w)}; }

// exp
inline float exp(float v) { return ::std::exp(v); }
inline float2 exp(const float2& v) { return {::std::exp(v.x), ::std::exp(v.y)}; }
inline float3 exp(const float3& v) { return {::std::exp(v.x), ::std::exp(v.y), ::std::exp(v.z)}; }
inline float4 exp(const float4& v) { return {::std::exp(v.x), ::std::exp(v.y), ::std::exp(v.z), ::std::exp(v.w)}; }

// exp2
inline float exp2(float v) { return ::std::exp2(v); }
inline float2 exp2(const float2& v) { return {::std::exp2(v.x), ::std::exp2(v.y)}; }
inline float3 exp2(const float3& v) { return {::std::exp2(v.x), ::std::exp2(v.y), ::std::exp2(v.z)}; }
inline float4 exp2(const float4& v) { return {::std::exp2(v.x), ::std::exp2(v.y), ::std::exp2(v.z), ::std::exp2(v.w)}; }

// log
inline float log(float v) { return ::std::log(v); }
inline float2 log(const float2& v) { return {::std::log(v.x), ::std::log(v.y)}; }
inline float3 log(const float3& v) { return {::std::log(v.x), ::std::log(v.y), ::std::log(v.z)}; }
inline float4 log(const float4& v) { return {::std::log(v.x), ::std::log(v.y), ::std::log(v.z), ::std::log(v.w)}; }

// log2
inline float log2(float v) { return ::std::log2(v); }
inline float2 log2(const float2& v) { return {::std::log2(v.x), ::std::log2(v.y)}; }
inline float3 log2(const float3& v) { return {::std::log2(v.x), ::std::log2(v.y), ::std::log2(v.z)}; }
inline float4 log2(const float4& v) { return {::std::log2(v.x), ::std::log2(v.y), ::std::log2(v.z), ::std::log2(v.w)}; }

// log10
inline float log10(float v) { return ::std::log10(v); }
inline float2 log10(const float2& v) { return {::std::log10(v.x), ::std::log10(v.y)}; }
inline float3 log10(const float3& v) { return {::std::log10(v.x), ::std::log10(v.y), ::std::log10(v.z)}; }
inline float4 log10(const float4& v) { return {::std::log10(v.x), ::std::log10(v.y), ::std::log10(v.z), ::std::log10(v.w)}; }

// logx
inline float logx(const float &v, const float &base) { return ::std::log(v) / ::std::log(base); }
inline float2 logx(const float2 &v, const float2 &base) { return {logx(v.x, base.x), logx(v.y, base.y)}; }
inline float3 logx(const float3 &v, const float3 &base) { return {logx(v.x, base.x), logx(v.y, base.y), logx(v.z, base.z)}; }
inline float4 logx(const float4 &v, const float4 &base) { return {logx(v.x, base.x), logx(v.y, base.y), logx(v.z, base.z), logx(v.w, base.w)}; }

// isfinite
inline bool isfinite(float v) { return ::std::isfinite(v); }
inline bool2 isfinite(const float2& v) { return {::std::isfinite(v.x), ::std::isfinite(v.y)}; }
inline bool3 isfinite(const float3& v) { return {::std::isfinite(v.x), ::std::isfinite(v.y), ::std::isfinite(v.z)}; }
inline bool4 isfinite(const float4& v) { return {::std::isfinite(v.x), ::std::isfinite(v.y), ::std::isfinite(v.z), ::std::isfinite(v.w)}; }

// isinf
inline bool isinf(float v) { return ::std::isinf(v); }
inline bool2 isinf(const float2& v) { return {::std::isinf(v.x), ::std::isinf(v.y)}; }
inline bool3 isinf(const float3& v) { return {::std::isinf(v.x), ::std::isinf(v.y), ::std::isinf(v.z)}; }
inline bool4 isinf(const float4& v) { return {::std::isinf(v.x), ::std::isinf(v.y), ::std::isinf(v.z), ::std::isinf(v.w)}; }

// isnan
inline bool isnan(float v) { return ::std::isnan(v); }
inline bool2 isnan(const float2& v) { return {::std::isnan(v.x), ::std::isnan(v.y)}; }
inline bool3 isnan(const float3& v) { return {::std::isnan(v.x), ::std::isnan(v.y), ::std::isnan(v.z)}; }
inline bool4 isnan(const float4& v) { return {::std::isnan(v.x), ::std::isnan(v.y), ::std::isnan(v.z), ::std::isnan(v.w)}; }

// max
float max(float v1, float v2);
float2 max(const float2& v1, const float2& v2);
float3 max(const float3& v1, const float3& v2);
float4 max(const float4& v1, const float4& v2);

// min
float min(float v1, float v2);
float2 min(const float2& v1, const float2& v2);
float3 min(const float3& v1, const float3& v2);
float4 min(const float4& v1, const float4& v2);

// mad
inline float mad(float x, float mul, float add) { return ::std::fma(x, mul, add); }
inline float2 mad(const float2& x, const float2& mul, const float2& add) { return {::std::fma(x.x, mul.x, add.x), ::std::fma(x.y, mul.y, add.y)}; }
inline float3 mad(const float3& x, const float3& mul, const float3& add) { return {::std::fma(x.x, mul.x, add.x), ::std::fma(x.y, mul.y, add.y), ::std::fma(x.z, mul.z, add.z)}; }
inline float4 mad(const float4& x, const float4& mul, const float4& add) { return {::std::fma(x.x, mul.x, add.x), ::std::fma(x.y, mul.y, add.y), ::std::fma(x.z, mul.z, add.z), ::std::fma(x.w, mul.w, add.w)}; }

// pow
inline float pow(float x, float y) { return ::std::pow(x, y); }
inline float2 pow(const float2& x, const float2& y) { return {::std::pow(x.x, y.x), ::std::pow(x.y, y.y)}; }
inline float3 pow(const float3& x, const float3& y) { return {::std::pow(x.x, y.x), ::std::pow(x.y, y.y), ::std::pow(x.z, y.z)}; }
inline float4 pow(const float4& x, const float4& y) { return {::std::pow(x.x, y.x), ::std::pow(x.y, y.y), ::std::pow(x.z, y.z), ::std::pow(x.w, y.w)}; }

// sqrt
inline float sqrt(float v) { return ::std::sqrt(v); }
inline float2 sqrt(const float2& v) { return {::std::sqrt(v.x), ::std::sqrt(v.y)}; }
inline float3 sqrt(const float3& v) { return {::std::sqrt(v.x), ::std::sqrt(v.y), ::std::sqrt(v.z)}; }
inline float4 sqrt(const float4& v) { return {::std::sqrt(v.x), ::std::sqrt(v.y), ::std::sqrt(v.z), ::std::sqrt(v.w)}; }

// rsqrt
inline float rsqrt(const float &v) { return float(1) / ::std::sqrt(v); }
inline float2 rsqrt(const float2 &v) { return {float(1) / ::std::sqrt(v.x), float(1) / ::std::sqrt(v.y)}; }
inline float3 rsqrt(const float3 &v) { return {float(1) / ::std::sqrt(v.x), float(1) / ::std::sqrt(v.y), float(1) / ::std::sqrt(v.z)}; }
inline float4 rsqrt(const float4 &v) { return {float(1) / ::std::sqrt(v.x), float(1) / ::std::sqrt(v.y), float(1) / ::std::sqrt(v.z), float(1) / ::std::sqrt(v.w)}; }

// cbrt
inline float cbrt(float v) { return ::std::cbrt(v); }
inline float2 cbrt(const float2& v) { return {::std::cbrt(v.x), ::std::cbrt(v.y)}; }
inline float3 cbrt(const float3& v) { return {::std::cbrt(v.x), ::std::cbrt(v.y), ::std::cbrt(v.z)}; }
inline float4 cbrt(const float4& v) { return {::std::cbrt(v.x), ::std::cbrt(v.y), ::std::cbrt(v.z), ::std::cbrt(v.w)}; }

// hypot
inline float hypot(float x, float y) { return ::std::hypot(x, y); }
inline float hypot(float x, float y, float z) { return ::std::hypot(x, y, z); }
inline float2 hypot(const float2& x, const float2& y) { return {::std::hypot(x.x, y.x), ::std::hypot(x.y, y.y)}; }
inline float2 hypot(const float2& x, const float2& y, const float2& z) { return {::std::hypot(x.x, y.x, z.x), ::std::hypot(x.y, y.y, z.y)}; }
inline float3 hypot(const float3& x, const float3& y) { return {::std::hypot(x.x, y.x), ::std::hypot(x.y, y.y), ::std::hypot(x.z, y.z)}; }
inline float3 hypot(const float3& x, const float3& y, const float3& z) { return {::std::hypot(x.x, y.x, z.x), ::std::hypot(x.y, y.y, z.y), ::std::hypot(x.z, y.z, z.z)}; }
inline float4 hypot(const float4& x, const float4& y) { return {::std::hypot(x.x, y.x), ::std::hypot(x.y, y.y), ::std::hypot(x.z, y.z), ::std::hypot(x.w, y.w)}; }
inline float4 hypot(const float4& x, const float4& y, const float4& z) { return {::std::hypot(x.x, y.x, z.x), ::std::hypot(x.y, y.y, z.y), ::std::hypot(x.z, y.z, z.z), ::std::hypot(x.w, y.w, z.w)}; }

// clamp
inline float clamp(const float &v, const float &min, const float &max) { return v < min ? min : v > max ? max : v; }
inline float2 clamp(const float2 &v, const float2 &min, const float2 &max) { return {clamp(v.x, min.x, max.x), clamp(v.y, min.y, max.y)}; }
inline float3 clamp(const float3 &v, const float3 &min, const float3 &max) { return {clamp(v.x, min.x, max.x), clamp(v.y, min.y, max.y), clamp(v.z, min.z, max.z)}; }
inline float4 clamp(const float4 &v, const float4 &min, const float4 &max) { return {clamp(v.x, min.x, max.x), clamp(v.y, min.y, max.y), clamp(v.z, min.z, max.z), clamp(v.w, min.w, max.w)}; }

// saturate
inline float saturate(const float &v) { return clamp(v, float(0), float(1)); }
inline float2 saturate(const float2 &v) { return {clamp(v.x, float(0), float(1)), clamp(v.y, float(0), float(1))}; }
inline float3 saturate(const float3 &v) { return {clamp(v.x, float(0), float(1)), clamp(v.y, float(0), float(1)), clamp(v.z, float(0), float(1))}; }
inline float4 saturate(const float4 &v) { return {clamp(v.x, float(0), float(1)), clamp(v.y, float(0), float(1)), clamp(v.z, float(0), float(1)), clamp(v.w, float(0), float(1))}; }

// select
inline float2 select(bool2 c, float2 if_true, float2 if_false) { return { c.x ? if_true.x : if_false.x, c.y ? if_true.y : if_false.y }; }
inline float3 select(bool3 c, float3 if_true, float3 if_false) { return { c.x ? if_true.x : if_false.x, c.y ? if_true.y : if_false.y, c.z ? if_true.z : if_false.z }; }
inline float4 select(bool4 c, float4 if_true, float4 if_false) { return { c.x ? if_true.x : if_false.x, c.y ? if_true.y : if_false.y, c.z ? if_true.z : if_false.z, c.w ? if_true.w : if_false.w }; }

// rcp
inline float rcp(const float &v) { return float(1) / v; }
inline float2 rcp(const float2 &v) { return {float(1) / v.x, float(1) / v.y}; }
inline float3 rcp(const float3 &v) { return {float(1) / v.x, float(1) / v.y, float(1) / v.z}; }
inline float4 rcp(const float4 &v) { return {float(1) / v.x, float(1) / v.y, float(1) / v.z, float(1) / v.w}; }

// sign
inline float sign(const float &v) { return v < float(0) ? float(-1) : v > float(0) ? float(1) : float(0); }
inline float2 sign(const float2 &v) { return {v.x < float(0) ? float(-1) : v.x > float(0) ? float(1) : float(0), v.y < float(0) ? float(-1) : v.y > float(0) ? float(1) : float(0)}; }
inline float3 sign(const float3 &v) { return {v.x < float(0) ? float(-1) : v.x > float(0) ? float(1) : float(0), v.y < float(0) ? float(-1) : v.y > float(0) ? float(1) : float(0), v.z < float(0) ? float(-1) : v.z > float(0) ? float(1) : float(0)}; }
inline float4 sign(const float4 &v) { return {v.x < float(0) ? float(-1) : v.x > float(0) ? float(1) : float(0), v.y < float(0) ? float(-1) : v.y > float(0) ? float(1) : float(0), v.z < float(0) ? float(-1) : v.z > float(0) ? float(1) : float(0), v.w < float(0) ? float(-1) : v.w > float(0) ? float(1) : float(0)}; }

// degrees
inline float degrees(const float &v) { return v * float(180) / float(kPi); }
inline float2 degrees(const float2 &v) { return {v.x * float(180) / float(kPi), v.y * float(180) / float(kPi)}; }
inline float3 degrees(const float3 &v) { return {v.x * float(180) / float(kPi), v.y * float(180) / float(kPi), v.z * float(180) / float(kPi)}; }
inline float4 degrees(const float4 &v) { return {v.x * float(180) / float(kPi), v.y * float(180) / float(kPi), v.z * float(180) / float(kPi), v.w * float(180) / float(kPi)}; }

// radians
inline float radians(const float &v) { return v * float(kPi) / float(180); }
inline float2 radians(const float2 &v) { return {v.x * float(kPi) / float(180), v.y * float(kPi) / float(180)}; }
inline float3 radians(const float3 &v) { return {v.x * float(kPi) / float(180), v.y * float(kPi) / float(180), v.z * float(kPi) / float(180)}; }
inline float4 radians(const float4 &v) { return {v.x * float(kPi) / float(180), v.y * float(kPi) / float(180), v.z * float(kPi) / float(180), v.w * float(kPi) / float(180)}; }

// dot
inline float dot(const float2 &v1, const float2 &v2) { return v1.x * v2.x + v1.y * v2.y; }
inline float dot(const float3 &v1, const float3 &v2) { return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z; }
inline float dot(const float4 &v1, const float4 &v2) { return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z + v1.w * v2.w; }

// cross
inline float3 cross(const float3 &x, const float3 &y) { return {(x * y.yzx() - x.yzx() * y).yzx()}; }

// length
inline float length(const float2 &v) { return ::std::sqrt(dot(v, v)); }
inline float length(const float3 &v) { return ::std::sqrt(dot(v, v)); }
inline float length(const float4 &v) { return ::std::sqrt(dot(v, v)); }

// length_squared
inline float length_squared(const float2 &v) { return dot(v, v); }
inline float length_squared(const float3 &v) { return dot(v, v); }
inline float length_squared(const float4 &v) { return dot(v, v); }

// distance
inline float distance(const float2 &x, const float2 &y) { return length_squared(y - x); }
inline float distance(const float3 &x, const float3 &y) { return length_squared(y - x); }
inline float distance(const float4 &x, const float4 &y) { return length_squared(y - x); }

// distance_squared
inline float distance_squared(const float2 &x, const float2 &y) { return length(y - x); }
inline float distance_squared(const float3 &x, const float3 &y) { return length(y - x); }
inline float distance_squared(const float4 &x, const float4 &y) { return length(y - x); }

// normalize
inline float2 normalize(const float2 &v) { return v / length(v); }
inline float3 normalize(const float3 &v) { return v / length(v); }
inline float4 normalize(const float4 &v) { return v / length(v); }

// reflect
inline float2 reflect(const float2 &v, const float2 &n) { return v - 2 * dot(n, v) * n; }
inline float3 reflect(const float3 &v, const float3 &n) { return v - 2 * dot(n, v) * n; }

// refract
inline float2 refract(const float2 &v, const float2 &n, float eta) {
    const float cos_i = dot(-v, n);
    const float cos_t2 = float(1) - eta * eta * (float(1) - cos_i * cos_i);
    const float2 t = eta * v + (eta * cos_i - ::std::sqrt(::std::abs(cos_t2))) * n;
    return t * float2(cos_t2 > 0);
}
inline float3 refract(const float3 &v, const float3 &n, float eta) {
    const float cos_i = dot(-v, n);
    const float cos_t2 = float(1) - eta * eta * (float(1) - cos_i * cos_i);
    const float3 t = eta * v + (eta * cos_i - ::std::sqrt(::std::abs(cos_t2))) * n;
    return t * float3(cos_t2 > 0);
}

// step
inline float step(const float &edge, const float &v) { return v < edge ? float(0) : float(1); }
inline float2 step(const float2 &edge, const float2 &v) { return select(edge < v, float2(0), float2(1)); }
inline float3 step(const float3 &edge, const float3 &v) { return select(edge < v, float3(0), float3(1)); }
inline float4 step(const float4 &edge, const float4 &v) { return select(edge < v, float4(0), float4(1)); }

// smoothstep
inline float smoothstep(const float &edge0, const float &edge1, const float &v) {
    const float t = saturate((v - edge0) / (edge1 - edge0));
    return t * t * (float(3) - float(2) * v);
}
inline float2 smoothstep(const float2 &edge0, const float2 &edge1, const float2 &v) {
    const float2 t = saturate((v - edge0) / (edge1 - edge0));
    return t * t * (float(3) - float(2) * v);
}
inline float3 smoothstep(const float3 &edge0, const float3 &edge1, const float3 &v) {
    const float3 t = saturate((v - edge0) / (edge1 - edge0));
    return t * t * (float(3) - float(2) * v);
}
inline float4 smoothstep(const float4 &edge0, const float4 &edge1, const float4 &v) {
    const float4 t = saturate((v - edge0) / (edge1 - edge0));
    return t * t * (float(3) - float(2) * v);
}

// lerp
inline float lerp(const float &v0, const float &v1, const float &t) { return v0 + t * (v1 - v0); }
inline float2 lerp(const float2 &v0, const float2 &v1, const float &t) { return v0 + t * (v1 - v0); }
inline float3 lerp(const float3 &v0, const float3 &v1, const float &t) { return v0 + t * (v1 - v0); }
inline float4 lerp(const float4 &v0, const float4 &v1, const float &t) { return v0 + t * (v1 - v0); }

// nearly_equal
inline bool nearly_equal(float x, float y, float epsilon = float(0.000001)) { return abs(x - y) <= epsilon; }
inline bool2 nearly_equal(const float2& x, const float2& y, float epsilon = float(0.000001)) { return { (abs(x.x - y.x) <= epsilon), (abs(x.y - y.y) <= epsilon) }; }
inline bool3 nearly_equal(const float3& x, const float3& y, float epsilon = float(0.000001)) { return { (abs(x.x - y.x) <= epsilon), (abs(x.y - y.y) <= epsilon), (abs(x.z - y.z) <= epsilon) }; }
inline bool4 nearly_equal(const float4& x, const float4& y, float epsilon = float(0.000001)) { return { (abs(x.x - y.x) <= epsilon), (abs(x.y - y.y) <= epsilon), (abs(x.z - y.z) <= epsilon), (abs(x.w - y.w) <= epsilon) }; }

// clamp_radians
inline float clamp_radians(float v) {
    v = fmod(v, float(kPi2));
    if (v < float(0)) {
        v += float(kPi2);
    }
    return v;
}
inline float2 clamp_radians(const float2 &v) { return { clamp_radians(v.x), clamp_radians(v.y) }; }
inline float3 clamp_radians(const float3 &v) { return { clamp_radians(v.x), clamp_radians(v.y), clamp_radians(v.z) }; }
inline float4 clamp_radians(const float4 &v) { return { clamp_radians(v.x), clamp_radians(v.y), clamp_radians(v.z), clamp_radians(v.w) }; }

// clamp_degrees
inline float clamp_degrees(float v) {
    v = fmod(v, float(360));
    if (v < float(0)) {
        v += float(360);
    }
    return v;
}
inline float2 clamp_degrees(const float2 &v) { return { clamp_degrees(v.x), clamp_degrees(v.y) }; }
inline float3 clamp_degrees(const float3 &v) { return { clamp_degrees(v.x), clamp_degrees(v.y), clamp_degrees(v.z) }; }
inline float4 clamp_degrees(const float4 &v) { return { clamp_degrees(v.x), clamp_degrees(v.y), clamp_degrees(v.z), clamp_degrees(v.w) }; }

// normalize_radians
inline float normalize_radians(float v) {
    v = clamp_radians(v);
    if (v > float(kPi)) {
        v -= float(kPi2);
    }
    return v;
}
inline float2 normalize_radians(const float2 &v) { return { normalize_radians(v.x), normalize_radians(v.y) }; }
inline float3 normalize_radians(const float3 &v) { return { normalize_radians(v.x), normalize_radians(v.y), normalize_radians(v.z) }; }
inline float4 normalize_radians(const float4 &v) { return { normalize_radians(v.x), normalize_radians(v.y), normalize_radians(v.z), normalize_radians(v.w) }; }

// normalize_degrees
inline float normalize_degrees(float v) {
    v = clamp_degrees(v);
    if (v > float(180)) {
        v -= float(360);
    }
    return v;
}
inline float2 normalize_degrees(const float2 &v) { return { normalize_degrees(v.x), normalize_degrees(v.y) }; }
inline float3 normalize_degrees(const float3 &v) { return { normalize_degrees(v.x), normalize_degrees(v.y), normalize_degrees(v.z) }; }
inline float4 normalize_degrees(const float4 &v) { return { normalize_degrees(v.x), normalize_degrees(v.y), normalize_degrees(v.z), normalize_degrees(v.w) }; }

// square
inline float square(const float &v) { return v * v; }
inline float2 square(const float2 &v) { return { v.x * v.x, v.y * v.y }; }
inline float3 square(const float3 &v) { return { v.x * v.x, v.y * v.y, v.z * v.z }; }
inline float4 square(const float4 &v) { return { v.x * v.x, v.y * v.y, v.z * v.z, v.w * v.w }; }

// cube
inline float cube(const float &v) { return v * v * v; }
inline float2 cube(const float2 &v) { return { v.x * v.x * v.x, v.y * v.y * v.y }; }
inline float3 cube(const float3 &v) { return { v.x * v.x * v.x, v.y * v.y * v.y, v.z * v.z * v.z }; }
inline float4 cube(const float4 &v) { return { v.x * v.x * v.x, v.y * v.y * v.y, v.z * v.z * v.z, v.w * v.w * v.w }; }

}
}
