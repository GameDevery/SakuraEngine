//! *************************************************************************
//! **  This file is auto-generated by gen_math, do not edit it manually.  **
//! *************************************************************************

#pragma once
#include "../vec/gen_vector.hpp"
#include "../mat/gen_matrix.hpp"
#include "../math/gen_math_func.hpp"
#include "./quat.hpp"

namespace skr {
inline namespace math {
struct TransformF {
    alignas(16) QuatF rotation;
    alignas(16) float3 position;
    alignas(16) float3 scale;
    
    // ctor & dtor
    inline TransformF() = default;
    inline TransformF(MathNoInitType) : rotation(kMathNoInit), position(kMathNoInit), scale(kMathNoInit) {}
    inline TransformF(const QuatF& rotation, const float3& position, const float3& scale) : rotation(rotation), position(position), scale(scale) {}
    inline ~TransformF() = default;
    
    // factory
    inline static TransformF Identity() { return { QuatF::Identity(), float3(0), float3(1) }; }
    
    // copy & move & assign & move assign
    inline TransformF(TransformF const&) = default;
    inline TransformF(TransformF&&) = default;
    inline TransformF& operator=(TransformF const&) = default;
    inline TransformF& operator=(TransformF&&) = default;
    
    // mul assign operator
    TransformF& operator*=(const TransformF& rhs);
    
    // identity
    bool is_identity() const;
    bool is_nearly_identity(float threshold = float(0.00001)) const;
    
    // to matrix
    operator float4x4() const;
    float4x4 to_matrix() const;
    float4x4 to_matrix_no_scale() const;
    
    // from matrix
    TransformF(const float3x3& mat);
    TransformF(const float4x4& mat);
    static TransformF FromMatrix(const float3x3& mat);
    static TransformF FromMatrix(const float4x4& mat);
    
    // directions
    float3 right() const;
    float3 up() const;
    float3 forward() const;
    float3 left() const;
    float3 down() const;
    float3 back() const;
    
};
struct TransformD {
    alignas(16) QuatD rotation;
    alignas(16) double3 position;
    alignas(16) double3 scale;
    
    // ctor & dtor
    inline TransformD() = default;
    inline TransformD(MathNoInitType) : rotation(kMathNoInit), position(kMathNoInit), scale(kMathNoInit) {}
    inline TransformD(const QuatD& rotation, const double3& position, const double3& scale) : rotation(rotation), position(position), scale(scale) {}
    inline ~TransformD() = default;
    
    // factory
    inline static TransformD Identity() { return { QuatD::Identity(), double3(0), double3(1) }; }
    
    // copy & move & assign & move assign
    inline TransformD(TransformD const&) = default;
    inline TransformD(TransformD&&) = default;
    inline TransformD& operator=(TransformD const&) = default;
    inline TransformD& operator=(TransformD&&) = default;
    
    // mul assign operator
    TransformD& operator*=(const TransformD& rhs);
    
    // identity
    bool is_identity() const;
    bool is_nearly_identity(double threshold = double(0.00001)) const;
    
    // to matrix
    operator double4x4() const;
    double4x4 to_matrix() const;
    double4x4 to_matrix_no_scale() const;
    
    // from matrix
    TransformD(const double3x3& mat);
    TransformD(const double4x4& mat);
    static TransformD FromMatrix(const double3x3& mat);
    static TransformD FromMatrix(const double4x4& mat);
    
    // directions
    double3 right() const;
    double3 up() const;
    double3 forward() const;
    double3 left() const;
    double3 down() const;
    double3 back() const;
    
};
}
}
