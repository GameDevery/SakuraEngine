//! *************************************************************************
//! **  This file is auto-generated by gen_math, do not edit it manually.  **
//! *************************************************************************

#pragma once
#include <cstdint>
#include <cmath>
#include "../gen_math_fwd.hpp"
#include "../vec/float_vec.hpp"
#include <SkrBase/misc/debug.h>
#include <SkrBase/misc/hash.hpp>

namespace skr {
inline namespace math {
struct float3x3 {
    union {
        // base axis
        struct {
            float3 axis_x;
            float3 axis_y;
            float3 axis_z;
        };
        
        // base columns
        float3 columns[3];
        
        // vector based
        struct {
            float m00, m10, m20;
            float m01, m11, m21;
            float m02, m12, m22;
        };
    };
    
    // ctor & dtor
    inline float3x3() : axis_x(0), axis_y(0), axis_z(0) {}
    inline float3x3(
        float m00, float m01, float m02,
        float m10, float m11, float m12,
        float m20, float m21, float m22
    ):
        m00(m00), m10(m10), m20(m20),
        m01(m01), m11(m11), m21(m21),
        m02(m02), m12(m12), m22(m22)
    {}
    inline float3x3(float3 axis_x, float3 axis_y, float3 axis_z) noexcept : axis_x(axis_x), axis_y(axis_y), axis_z(axis_z) {}
    inline ~float3x3() = default;
    
    // convert with other dimensions
    explicit float3x3(const float4x4& rhs);
    
    // convert with other component kinds
    explicit float3x3(const double3x3& rhs);
    
    // factory
    inline static float3x3 eye(float v) {
        return float3x3{
            v, 0, 0,
            0, v, 0,
            0, 0, v
        };
    }
    inline static float3x3 fill(float v) {
        return float3x3{
            v, v, v,
            v, v, v,
            v, v, v
        };
    }
    inline static float3x3 identity() { return eye(1); }
    inline static float3x3 zero() { return fill(0); }
    inline static float3x3 one() { return fill(1); }
    
    // copy & move & assign & move assign
    inline float3x3(const float3x3& rhs) noexcept : axis_x(rhs.axis_x), axis_y(rhs.axis_y), axis_z(rhs.axis_z) {}
    inline float3x3(float3x3&& rhs) noexcept : axis_x(std::move(rhs.axis_x)), axis_y(std::move(rhs.axis_y)), axis_z(std::move(rhs.axis_z)) {}
    inline float3x3& operator=(const float3x3& rhs) noexcept { this->axis_x = rhs.axis_x; this->axis_y = rhs.axis_y; this->axis_z = rhs.axis_z; return *this; }
    inline float3x3& operator=(float3x3&& rhs) noexcept { this->axis_x = std::move(rhs.axis_x); this->axis_y = std::move(rhs.axis_y); this->axis_z = std::move(rhs.axis_z); return *this; }
    
    // mul operator
    friend float3x3 operator*(const float3x3& lhs, const float3x3& rhs);
    float3x3& operator*=(const float3x3& rhs);
    friend float3 operator*(const float3& lhs, const float3x3& rhs);
};
struct alignas(16) float4x4 {
    union {
        // base axis
        struct {
            float4 axis_x;
            float4 axis_y;
            float4 axis_z;
            float4 axis_w;
        };
        
        // base columns
        float4 columns[4];
        
        // vector based
        struct {
            float m00, m10, m20, m30;
            float m01, m11, m21, m31;
            float m02, m12, m22, m32;
            float m03, m13, m23, m33;
        };
    };
    
    // ctor & dtor
    inline float4x4() : axis_x(0), axis_y(0), axis_z(0), axis_w(0) {}
    inline float4x4(
        float m00, float m01, float m02, float m03,
        float m10, float m11, float m12, float m13,
        float m20, float m21, float m22, float m23,
        float m30, float m31, float m32, float m33
    ):
        m00(m00), m10(m10), m20(m20), m30(m30),
        m01(m01), m11(m11), m21(m21), m31(m31),
        m02(m02), m12(m12), m22(m22), m32(m32),
        m03(m03), m13(m13), m23(m23), m33(m33)
    {}
    inline float4x4(float4 axis_x, float4 axis_y, float4 axis_z, float4 axis_w) noexcept : axis_x(axis_x), axis_y(axis_y), axis_z(axis_z), axis_w(axis_w) {}
    inline ~float4x4() = default;
    
    // convert with other dimensions
    explicit float4x4(const float3x3& rhs);
    
    // convert with other component kinds
    explicit float4x4(const double4x4& rhs);
    
    // factory
    inline static float4x4 eye(float v) {
        return float4x4{
            v, 0, 0, 0,
            0, v, 0, 0,
            0, 0, v, 0,
            0, 0, 0, v
        };
    }
    inline static float4x4 fill(float v) {
        return float4x4{
            v, v, v, v,
            v, v, v, v,
            v, v, v, v,
            v, v, v, v
        };
    }
    inline static float4x4 identity() { return eye(1); }
    inline static float4x4 zero() { return fill(0); }
    inline static float4x4 one() { return fill(1); }
    
    // copy & move & assign & move assign
    inline float4x4(const float4x4& rhs) noexcept : axis_x(rhs.axis_x), axis_y(rhs.axis_y), axis_z(rhs.axis_z), axis_w(rhs.axis_w) {}
    inline float4x4(float4x4&& rhs) noexcept : axis_x(std::move(rhs.axis_x)), axis_y(std::move(rhs.axis_y)), axis_z(std::move(rhs.axis_z)), axis_w(std::move(rhs.axis_w)) {}
    inline float4x4& operator=(const float4x4& rhs) noexcept { this->axis_x = rhs.axis_x; this->axis_y = rhs.axis_y; this->axis_z = rhs.axis_z; this->axis_w = rhs.axis_w; return *this; }
    inline float4x4& operator=(float4x4&& rhs) noexcept { this->axis_x = std::move(rhs.axis_x); this->axis_y = std::move(rhs.axis_y); this->axis_z = std::move(rhs.axis_z); this->axis_w = std::move(rhs.axis_w); return *this; }
    
    // mul operator
    friend float4x4 operator*(const float4x4& lhs, const float4x4& rhs);
    float4x4& operator*=(const float4x4& rhs);
    friend float4 operator*(const float4& lhs, const float4x4& rhs);
};

}
}
