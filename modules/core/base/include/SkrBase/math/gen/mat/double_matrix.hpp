//! *************************************************************************
//! **  This file is auto-generated by gen_math, do not edit it manually.  **
//! *************************************************************************

#pragma once
#include <cstdint>
#include <cmath>
#include "../gen_math_fwd.hpp"
#include "../vec/double_vec.hpp"
#include <SkrBase/misc/debug.h>
#include <SkrBase/misc/hash.hpp>

namespace skr {
inline namespace math {
struct double3x3 {
    union {
        // base axis
        struct {
            double3 axis_x;
            double3 axis_y;
            double3 axis_z;
        };
        
        // base columns
        double3 columns[3];
        
        // vector based
        struct {
            double m00, m10, m20;
            double m01, m11, m21;
            double m02, m12, m22;
        };
    };
    // ctor & dtor
    inline double3x3() /*do noting for performance purpose, use factory init will be better*/ {}
    inline double3x3(
        float m00, float m01, float m02,
        float m10, float m11, float m12,
        float m20, float m21, float m22
    ):
        m00(m00), m10(m10), m20(m20),
        m01(m01), m11(m11), m21(m21),
        m02(m02), m12(m12), m22(m22)
    {}
    inline ~double3x3() = default;
    
    // factory
    inline static double3x3 eye(double v) {
        return double3x3{
            v, 0, 0,
            0, v, 0,
            0, 0, v
        };
    }
    inline static double3x3 fill(double v) {
        return double3x3{
            v, v, v,
            v, v, v,
            v, v, v
        };
    }
    inline static double3x3 identity() { return eye(1); }
    inline static double3x3 zero() { return fill(0); }
    inline static double3x3 one() { return fill(1); }
    
    // copy & move & assign & move assign
    inline double3x3(const double3x3& rhs) noexcept : axis_x(rhs.axis_x), axis_y(rhs.axis_y), axis_z(rhs.axis_z) {}
    inline double3x3(double3x3&& rhs) noexcept : axis_x(std::move(rhs.axis_x)), axis_y(std::move(rhs.axis_y)), axis_z(std::move(rhs.axis_z)) {}
    inline double3x3& operator=(const double3x3& rhs) noexcept { this->axis_x = rhs.axis_x; this->axis_y = rhs.axis_y; this->axis_z = rhs.axis_z; return *this; }
    inline double3x3& operator=(double3x3&& rhs) noexcept { this->axis_x = std::move(rhs.axis_x); this->axis_y = std::move(rhs.axis_y); this->axis_z = std::move(rhs.axis_z); return *this; }
};
struct double4x4 {
    union {
        // base axis
        struct {
            double4 axis_x;
            double4 axis_y;
            double4 axis_z;
            double4 axis_w;
        };
        
        // base columns
        double4 columns[4];
        
        // vector based
        struct {
            double m00, m10, m20, m30;
            double m01, m11, m21, m31;
            double m02, m12, m22, m32;
            double m03, m13, m23, m33;
        };
    };
    // ctor & dtor
    inline double4x4() /*do noting for performance purpose, use factory init will be better*/ {}
    inline double4x4(
        float m00, float m01, float m02, float m03,
        float m10, float m11, float m12, float m13,
        float m20, float m21, float m22, float m23,
        float m30, float m31, float m32, float m33
    ):
        m00(m00), m10(m10), m20(m20), m30(m30),
        m01(m01), m11(m11), m21(m21), m31(m31),
        m02(m02), m12(m12), m22(m22), m32(m32),
        m03(m03), m13(m13), m23(m23), m33(m33)
    {}
    inline ~double4x4() = default;
    
    // factory
    inline static double4x4 eye(double v) {
        return double4x4{
            v, 0, 0, 0,
            0, v, 0, 0,
            0, 0, v, 0,
            0, 0, 0, v
        };
    }
    inline static double4x4 fill(double v) {
        return double4x4{
            v, v, v, v,
            v, v, v, v,
            v, v, v, v,
            v, v, v, v
        };
    }
    inline static double4x4 identity() { return eye(1); }
    inline static double4x4 zero() { return fill(0); }
    inline static double4x4 one() { return fill(1); }
    
    // copy & move & assign & move assign
    inline double4x4(const double4x4& rhs) noexcept : axis_x(rhs.axis_x), axis_y(rhs.axis_y), axis_z(rhs.axis_z), axis_w(rhs.axis_w) {}
    inline double4x4(double4x4&& rhs) noexcept : axis_x(std::move(rhs.axis_x)), axis_y(std::move(rhs.axis_y)), axis_z(std::move(rhs.axis_z)), axis_w(std::move(rhs.axis_w)) {}
    inline double4x4& operator=(const double4x4& rhs) noexcept { this->axis_x = rhs.axis_x; this->axis_y = rhs.axis_y; this->axis_z = rhs.axis_z; this->axis_w = rhs.axis_w; return *this; }
    inline double4x4& operator=(double4x4&& rhs) noexcept { this->axis_x = std::move(rhs.axis_x); this->axis_y = std::move(rhs.axis_y); this->axis_z = std::move(rhs.axis_z); this->axis_w = std::move(rhs.axis_w); return *this; }
};
}
}
