//! *************************************************************************
//! **  This file is auto-generated by gen_math, do not edit it manually.  **
//! *************************************************************************

#pragma once
#include <cstdint>
#include <cmath>
#include "../gen_math_fwd.hpp"
#include "../vec/double_vec.hpp"
#include <SkrBase/misc/debug.h>
#include <SkrBase/misc/hash.hpp>

namespace skr {
inline namespace math {
struct double3x3 {
    union {
        // base axis
        struct {
            double3 axis_x;
            double3 axis_y;
            double3 axis_z;
        };
        
        // base columns
        double3 columns[3];
        
        // vector based
        struct {
            double m00, m10, m20;
            double m01, m11, m21;
            double m02, m12, m22;
        };
    };
    
    // ctor & dtor
    inline double3x3() : axis_x(0), axis_y(0), axis_z(0) {}
    inline double3x3(
        double m00, double m01, double m02,
        double m10, double m11, double m12,
        double m20, double m21, double m22
    ):
        m00(m00), m10(m10), m20(m20),
        m01(m01), m11(m11), m21(m21),
        m02(m02), m12(m12), m22(m22)
    {}
    inline double3x3(double3 axis_x, double3 axis_y, double3 axis_z) noexcept : axis_x(axis_x), axis_y(axis_y), axis_z(axis_z) {}
    inline ~double3x3() = default;
    
    // convert with other dimensions
    explicit double3x3(const double4x4& rhs);
    
    // convert with other component kinds
    double3x3(const float3x3& rhs);
    
    // factory
    inline static double3x3 eye(double v) {
        return double3x3{
            v, 0, 0,
            0, v, 0,
            0, 0, v
        };
    }
    inline static double3x3 fill(double v) {
        return double3x3{
            v, v, v,
            v, v, v,
            v, v, v
        };
    }
    inline static double3x3 identity() { return eye(1); }
    inline static double3x3 zero() { return fill(0); }
    inline static double3x3 one() { return fill(1); }
    
    // copy & move & assign & move assign
    inline double3x3(const double3x3& rhs) noexcept : axis_x(rhs.axis_x), axis_y(rhs.axis_y), axis_z(rhs.axis_z) {}
    inline double3x3(double3x3&& rhs) noexcept : axis_x(std::move(rhs.axis_x)), axis_y(std::move(rhs.axis_y)), axis_z(std::move(rhs.axis_z)) {}
    inline double3x3& operator=(const double3x3& rhs) noexcept { this->axis_x = rhs.axis_x; this->axis_y = rhs.axis_y; this->axis_z = rhs.axis_z; return *this; }
    inline double3x3& operator=(double3x3&& rhs) noexcept { this->axis_x = std::move(rhs.axis_x); this->axis_y = std::move(rhs.axis_y); this->axis_z = std::move(rhs.axis_z); return *this; }
    
    // mul operator
    friend double3x3 operator*(const double3x3& lhs, const double3x3& rhs);
    double3x3& operator*=(const double3x3& rhs);
    friend double3 operator*(const double3& lhs, const double3x3& rhs);
};
struct alignas(16) double4x4 {
    union {
        // base axis
        struct {
            double4 axis_x;
            double4 axis_y;
            double4 axis_z;
            double4 axis_w;
        };
        
        // base columns
        double4 columns[4];
        
        // vector based
        struct {
            double m00, m10, m20, m30;
            double m01, m11, m21, m31;
            double m02, m12, m22, m32;
            double m03, m13, m23, m33;
        };
    };
    
    // ctor & dtor
    inline double4x4() : axis_x(0), axis_y(0), axis_z(0), axis_w(0) {}
    inline double4x4(
        double m00, double m01, double m02, double m03,
        double m10, double m11, double m12, double m13,
        double m20, double m21, double m22, double m23,
        double m30, double m31, double m32, double m33
    ):
        m00(m00), m10(m10), m20(m20), m30(m30),
        m01(m01), m11(m11), m21(m21), m31(m31),
        m02(m02), m12(m12), m22(m22), m32(m32),
        m03(m03), m13(m13), m23(m23), m33(m33)
    {}
    inline double4x4(double4 axis_x, double4 axis_y, double4 axis_z, double4 axis_w) noexcept : axis_x(axis_x), axis_y(axis_y), axis_z(axis_z), axis_w(axis_w) {}
    inline ~double4x4() = default;
    
    // convert with other dimensions
    explicit double4x4(const double3x3& rhs);
    
    // convert with other component kinds
    double4x4(const float4x4& rhs);
    
    // factory
    inline static double4x4 eye(double v) {
        return double4x4{
            v, 0, 0, 0,
            0, v, 0, 0,
            0, 0, v, 0,
            0, 0, 0, v
        };
    }
    inline static double4x4 fill(double v) {
        return double4x4{
            v, v, v, v,
            v, v, v, v,
            v, v, v, v,
            v, v, v, v
        };
    }
    inline static double4x4 identity() { return eye(1); }
    inline static double4x4 zero() { return fill(0); }
    inline static double4x4 one() { return fill(1); }
    
    // copy & move & assign & move assign
    inline double4x4(const double4x4& rhs) noexcept : axis_x(rhs.axis_x), axis_y(rhs.axis_y), axis_z(rhs.axis_z), axis_w(rhs.axis_w) {}
    inline double4x4(double4x4&& rhs) noexcept : axis_x(std::move(rhs.axis_x)), axis_y(std::move(rhs.axis_y)), axis_z(std::move(rhs.axis_z)), axis_w(std::move(rhs.axis_w)) {}
    inline double4x4& operator=(const double4x4& rhs) noexcept { this->axis_x = rhs.axis_x; this->axis_y = rhs.axis_y; this->axis_z = rhs.axis_z; this->axis_w = rhs.axis_w; return *this; }
    inline double4x4& operator=(double4x4&& rhs) noexcept { this->axis_x = std::move(rhs.axis_x); this->axis_y = std::move(rhs.axis_y); this->axis_z = std::move(rhs.axis_z); this->axis_w = std::move(rhs.axis_w); return *this; }
    
    // mul operator
    friend double4x4 operator*(const double4x4& lhs, const double4x4& rhs);
    double4x4& operator*=(const double4x4& rhs);
    friend double4 operator*(const double4& lhs, const double4x4& rhs);
};

}
}
