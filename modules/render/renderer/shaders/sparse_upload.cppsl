#include <std/std.hpp>
#include <std2/constant_buffer.hpp>

using namespace skr::shader;

// Upload operation descriptor (must match C++ side)
struct Upload {
    uint64 src_offset;  // Offset in upload_buffer (bytes)
    uint64 dst_offset;  // Offset in target buffer (bytes)
    uint64 data_size;   // Data size (bytes)
};

// External resource bindings
extern ByteBuffer<CacheFlags::ReadOnly>& upload_buffer;     // Source data buffer
extern Buffer<Upload, CacheFlags::ReadOnly>& upload_operations;  // Copy operations list
extern ByteBuffer<>& target_buffer;     // Target buffer (Core Data)

// Push constants
struct SparseUploadConstants {
    uint num_operations;      // Number of operations
    uint alignment;           // Not used in simple version
};

[[push_constant]]
extern ConstantBuffer<SparseUploadConstants>& constants;

// Simple sparse upload - each thread handles one complete operation
[[compute_shader("sparse_upload"), kernel_1d(256)]]
void sparse_upload_main([[sv_thread_id]] uint3 thread_id)
{
    uint operation_index = thread_id.x;
    
    // Boundary check
    if (operation_index >= constants.num_operations) {
        return;
    }
    
    // Load the operation
    Upload op = upload_operations.load(operation_index);
    
    // Simple byte-by-byte copy (4 bytes at a time for ByteBuffer)
    uint src_dword_offset = op.src_offset;
    uint dst_dword_offset = op.dst_offset;
    uint size_in_dwords = op.data_size;
    
    // Copy data dword by dword
    for (uint i = 0; i < size_in_dwords; i++) {
        uint data = upload_buffer.load(src_dword_offset + i);
        target_buffer.store(dst_dword_offset + i, data);
    }
}