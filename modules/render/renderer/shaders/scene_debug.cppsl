#include <std/std.hpp>
#include <std2/attributes.hpp>
#include <std2/constant_buffer.hpp>
#include "SkrRenderer/shared/gpu_scene.hpp"
#include "SkrRenderer/shared/soa_layout.hpp"

using namespace skr::shader;

// External resource bindings
extern Image<float>& output_texture;
extern ByteBuffer<CacheFlags::ReadOnly>& gpu_scene_buffer; // Core data buffer from GPUScene

// Push constants for debug parameters
struct SceneDebugConstants 
{
    float2 screenSize;
    uint32 debug_mode;     // 0 = red fill, 1 = checkerboard, 2 = UV gradient, 3 = GPUScene color debug, 6 = 3D sphere rendering
    uint32 color_segment_offset; // Offset to color component in page (for paged layout)
    uint32 color_element_size;   // Size of each color element (typically 16 bytes for float4)
    uint32 instance_count;       // Number of instances in GPUScene
    uint32 transform_segment_offset; // Offset to transform component in page (for paged layout)
    uint32 transform_element_size;   // Size of each transform element (typically 64 bytes for float4x4)
    uint32 page_size;            // Page size in instances (UINT32_MAX for continuous layout)
    uint32 page_stride_bytes;    // Size of each page in bytes
};

[[push_constant]]
extern ConstantBuffer<SceneDebugConstants>& debug_constants;

// Simple red fill compute shader
[[compute_shader("scene_debug"), kernel_2d(16, 16)]]
void scene_debug([[sv_thread_id]] uint3 thread_id) 
{
    skr::renderer::GPUSceneObjectToWorld d;

    uint2 screen_size = uint2(debug_constants.screenSize);
    uint2 pixel_coord = thread_id.xy;
    
    // Boundary check
    if (any(pixel_coord >= screen_size)) {
        return;
    }
    
    // Debug rendering based on mode
    float4 pixel_color;
    
    switch (debug_constants.debug_mode) {
        case 0: // Red fill
        {
            pixel_color = float4(1.0f, 0.0f, 0.0f, 1.0f);
            break;
        }
            
        case 1: // Checkerboard pattern
        {
            float2 uv = float2(pixel_coord) / float2(screen_size);
            float checker_size = 32.0f;
            float2 checker_uv = uv * checker_size;
            uint2 checker_coord = uint2(checker_uv);
            bool is_even = ((checker_coord.x + checker_coord.y) % 2) == 0;
            pixel_color = is_even ? float4(1.0f, 0.0f, 0.0f, 1.0f) : float4(0.0f, 1.0f, 0.0f, 1.0f);
            break;
        }
        
        case 2: // UV gradient
        {
            float2 uv = float2(pixel_coord) / float2(screen_size);
            pixel_color = float4(uv.x, uv.y, 0.0f, 1.0f);
            break;
        }
        
        case 3: // GPUScene color debug - visualize color data from GPU buffer
        {
            // Map pixel position to instance index (show multiple instances in a grid)
            uint instances_per_row = uint(sqrt(float(debug_constants.instance_count))) + 1;
            uint block_size = uint(screen_size.x / instances_per_row);
            
            uint instance_x = pixel_coord.x / block_size;
            uint instance_y = pixel_coord.y / block_size;
            uint instance_index = instance_y * instances_per_row + instance_x;
            
            if (instance_index < debug_constants.instance_count) {
                // Use the DefaultGPUSceneLayout to calculate offset
                // Color is at SOAIndex 1 in the layout
                uint color_offset;
                if (debug_constants.page_size == 0xFFFFFFFF) {
                    // Continuous layout
                    color_offset = debug_constants.color_segment_offset + 
                                  (instance_index * debug_constants.color_element_size);
                } else {
                    // Paged layout - calculate using page logic
                    uint page = instance_index / debug_constants.page_size;
                    uint offset_in_page = instance_index % debug_constants.page_size;
                    color_offset = page * debug_constants.page_stride_bytes +
                                  debug_constants.color_segment_offset +
                                  offset_in_page * debug_constants.color_element_size;
                }
                
                // Read color data from GPU buffer (assuming float4 color)
                float4 instance_color;
                instance_color.x = gpu_scene_buffer.Load<float>(color_offset);
                instance_color.y = gpu_scene_buffer.Load<float>(color_offset + 4);
                instance_color.z = gpu_scene_buffer.Load<float>(color_offset + 8);
                instance_color.w = gpu_scene_buffer.Load<float>(color_offset + 12);
                
                // Draw border for each instance block
                uint2 block_coord = pixel_coord % block_size;
                if (block_coord.x < 2 || block_coord.y < 2 || 
                    block_coord.x >= block_size - 2 || block_coord.y >= block_size - 2) {
                    pixel_color = float4(0.0f, 0.0f, 0.0f, 1.0f); // Black border
                } else {
                    pixel_color = instance_color;
                }
            } else {
                // Background for areas without instances
                pixel_color = float4(0.2f, 0.2f, 0.2f, 1.0f);
            }
            break;
        }
        
        case 4: // Simple GPUScene validation - show first instance color across entire screen
        {
            if (debug_constants.instance_count > 0) {
                // Read the first instance's color (instance 0 is always at the beginning)
                uint color_offset = debug_constants.color_segment_offset;
                float4 first_color;
                first_color.x = gpu_scene_buffer.Load<float>(color_offset);
                first_color.y = gpu_scene_buffer.Load<float>(color_offset + 4);
                first_color.z = gpu_scene_buffer.Load<float>(color_offset + 8);
                first_color.w = gpu_scene_buffer.Load<float>(color_offset + 12);
                
                pixel_color = first_color;
                
                // Add instance count indicator in top-left corner
                if (pixel_coord.x < 100 && pixel_coord.y < 20) {
                    float indicator = float(pixel_coord.x) / 100.0f;
                    float normalized_count = float(debug_constants.instance_count) / 100.0f;
                    if (indicator < normalized_count) {
                        pixel_color = float4(0.0f, 1.0f, 0.0f, 1.0f); // Green bar showing instance count
                    }
                }
            } else {
                pixel_color = float4(0.5f, 0.0f, 0.0f, 1.0f); // Dark red for no instances
            }
            break;
        }
        
        case 5: // Test mode - show fixed color based on instance count
        {
            if (debug_constants.instance_count > 0) {
                // Show yellow if we have instances
                pixel_color = float4(1.0f, 1.0f, 0.0f, 1.0f);
                
                // Show debug info in corners
                if (pixel_coord.x < 200 && pixel_coord.y < 40) {
                    // Top-left: instance count bar
                    if (pixel_coord.y < 20) {
                        float indicator = float(pixel_coord.x) / 200.0f;
                        float normalized_count = float(debug_constants.instance_count) / 10000.0f;
                        if (indicator < normalized_count) {
                            pixel_color = float4(0.0f, 1.0f, 0.0f, 1.0f); // Green
                        }
                    } else {
                        // Show segment offset as blue gradient
                        float offset_norm = float(debug_constants.color_segment_offset) / 65536.0f;
                        pixel_color = float4(0.0f, 0.0f, offset_norm, 1.0f);
                    }
                }
            } else {
                pixel_color = float4(0.5f, 0.0f, 0.0f, 1.0f); // Dark red for no instances
            }
            break;
        }
        
        case 6: // 3D sphere rendering mode
        {
            // Convert pixel coordinates to NDC space (-1 to 1)
            float2 ndc = (float2(pixel_coord) / float2(screen_size)) * 2.0f - 1.0f;
            ndc.y = -ndc.y; // Flip Y coordinate for correct orientation
            
            // Simple orthographic projection - ray starts at (ndc.x, ndc.y, 1) going towards -Z
            float3 ray_origin = float3(ndc.x, ndc.y, 1.0f);
            float3 ray_direction = float3(0.0f, 0.0f, -1.0f);
            
            pixel_color = float4(0.1f, 0.1f, 0.2f, 1.0f); // Dark blue background
            float closest_distance = 10.0f; // Far distance
            
            // Check intersection with all sphere instances
            for (uint instance_index = 0; instance_index < debug_constants.instance_count; instance_index++) {
                // Calculate transform offset based on layout type
                // Transform is at SOAIndex 0 in the layout (part of bundle)
                uint transform_offset;
                if (debug_constants.page_size == 0xFFFFFFFF) {
                    // Continuous layout
                    transform_offset = debug_constants.transform_segment_offset + 
                                      (instance_index * debug_constants.transform_element_size);
                } else {
                    // Paged layout - same calculation as PagedLayout::component_location
                    uint page = instance_index / debug_constants.page_size;
                    uint offset_in_page = instance_index % debug_constants.page_size;
                    transform_offset = page * debug_constants.page_stride_bytes +
                                      debug_constants.transform_segment_offset +
                                      offset_in_page * debug_constants.transform_element_size;
                }
                
                // Load 4x4 transform matrix (16 floats = 64 bytes)
                float4x4 object_to_world;
                for (uint row = 0; row < 4; row++) {
                    for (uint col = 0; col < 4; col++) {
                        uint matrix_offset = transform_offset + (row * 4 + col) * 4;
                        object_to_world[row][col] = gpu_scene_buffer.Load<float>(matrix_offset);
                    }
                }
                
                // Extract position and scale from transform matrix
                // Position is in the 4th row (translation part)
                float3 sphere_center = float3(object_to_world[3][0], object_to_world[3][1], object_to_world[3][2]);
                // Scale is the length of the first column vector
                float sphere_radius = length(float3(object_to_world[0][0], object_to_world[1][0], object_to_world[2][0]));
                
                // Ray-sphere intersection test
                float3 to_center = ray_origin - sphere_center;
                float a = dot(ray_direction, ray_direction);
                float b = 2.0f * dot(to_center, ray_direction);
                float c = dot(to_center, to_center) - sphere_radius * sphere_radius;
                
                float discriminant = b * b - 4.0f * a * c;
                if (discriminant >= 0.0f) {
                    float distance = (-b - sqrt(discriminant)) / (2.0f * a);
                    if (distance > 0.0f && distance < closest_distance) {
                        closest_distance = distance;
                        
                        // Read color for this instance
                        uint color_offset;
                        if (debug_constants.page_size == 0xFFFFFFFF) {
                            // Continuous layout
                            color_offset = debug_constants.color_segment_offset + 
                                          (instance_index * debug_constants.color_element_size);
                        } else {
                            // Paged layout
                            uint page = instance_index / debug_constants.page_size;
                            uint offset_in_page = instance_index % debug_constants.page_size;
                            color_offset = page * debug_constants.page_stride_bytes +
                                          debug_constants.color_segment_offset +
                                          offset_in_page * debug_constants.color_element_size;
                        }
                        
                        float4 sphere_color;
                        sphere_color.x = gpu_scene_buffer.Load<float>(color_offset);
                        sphere_color.y = gpu_scene_buffer.Load<float>(color_offset + 4);
                        sphere_color.z = gpu_scene_buffer.Load<float>(color_offset + 8);
                        sphere_color.w = gpu_scene_buffer.Load<float>(color_offset + 12);
                        
                        // Simple lighting calculation
                        float3 hit_point = ray_origin + ray_direction * distance;
                        float3 normal = normalize(hit_point - sphere_center);
                        float3 light_dir = normalize(float3(1.0f, 1.0f, 1.0f));
                        float light_intensity = max(0.3f, dot(normal, light_dir));
                        
                        pixel_color = float4(sphere_color.rgb * light_intensity, sphere_color.a);
                    }
                }
            }
            break;
        }
        
        default: // Magenta for unknown mode
            pixel_color = float4(1.0f, 0.0f, 1.0f, 1.0f);
            break;
    }
    
    // Write pixel color to output texture
    output_texture.store(pixel_coord, pixel_color);
}